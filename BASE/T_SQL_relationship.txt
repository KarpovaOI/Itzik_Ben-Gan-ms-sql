Язык T-SQL имеет строгие математические основы. Он основывается на стандартном SQL, который, в свою очередь, основывается на реляционной модели, 
в свою очередь основывающейся на теории множеств и логике предикатов. (Предикат — это 
выражение, которое, будучи соотнесенным с некоторым объектом, делает 
высказывание истинным или ложным). 

T-SQL диалект разрабатываемый MS стандартного языка SQL. Т.о. основные элементы языка выглядят одинаково. При этом каждый поставщик решает, какие функции реализовать, а какие нет. 

Следование стандарту при написании кода считается наилучшим решением. 
Делает код более переносимым, делает более переносимыми знания, т.к. проще начать работать на новых платформах.
Если диалект поддерживает и стандартный и нестандартный способы выполнения каких либо операция, следует выбирать стандартный способ, нестандартный режим выбирать только в том случае, если он дает заметное преимущество, не предоставляемое стандартным режимом.(cast,';', <>)

Отношение представляется в SQL таблицей: отношение имеет заголовок и тело. 
Заголовок — это набор атрибутов (которые SQL пытается представить в виде столбцов), каждый определенного типа. 
Атрибут определяется именем и именем типа. 
Тело отношения представляет собой множество кортежей (которые SQL пытается представить в виде строк). 
Каждый заголовок кортежа — это заголовок отношения. 
Каждое значение атрибута кортежа имеет соответствующий тип. 

Важно понимать принципы реляционной модели и применять их при написании 
кода T-SQL: отношение имеет заголовок и тело, заголовок представляет собой множество атрибутов, а тело - множество кортежей. Множество рассматривается как единое целое. Поэтому, следует писать запросы взаимодействующие с таблицей как с единым целым
избегать использования итеративных конструкций, таких как курсоры и циклы, которые перебирают строки по одной. Также следует стараться не думать в итерационной манере, поскольку это неизбежно приведет к итерационным решениям
с точки зрения реляционной модели, правильным является не обращаться к строкам по отдельности, напротив, нужно использовать реляционные операции и возвращать реляционные результаты.

Про троичную логику:  при написании каждого фрагмента кода на T-SQL надо спросить 
себя, возможно ли присутствие NULL-значений в данных, с которыми вы будете 
взаимодействовать. Если да, вы должны быть уверены в том, что понимаете использование NULL-значений в вашем запросе и что ваши тесты специально направлены на проверку NULL-значений. 

Этапы логической обработки запросов 
1. FROM. 
2. WHERE. 
3. GROUP BY. 
4. HAVING. 
5. SELECT. 
6. ORDER BY

Каждый этап работает с одной или более таблицами на входе и возвращает виртуальную таблицу на выходе. Выходная таблица одного этапа рассматривается как 
входная для следующего этапа. Это полностью согласуется с операциями на отношении, которые дают в результате отношение. Обратите внимание, если указано 
предложение ORDER BY, результат не является реляционным

SELECT - выбор данных (не использовать * в продакшн коде, внимательно выбирать колонки, не использовать лишнего)
РБД не предусматривает удаление дублей, это задача разработчика (DISTINCT)
FROM - выбор таблиц, оператор соединения
WHERE - условие отбора
предикат проверяется для каждой строки и принимает 3 значения true/false/unknown в итог попадут строки с true
SARGability - поисковые предикаты, которые могут использовать поиск по индексу
https://sql-ex.ru/blogs/?/SARGability_chto_jeto_voobwe_takoe.html
пример не SARG предиката: столбец like '%что-то'и тд. (Index Seek не сработает)
Приоритет
0. NOT
1. (..) скобки
2. AND
3. OR
GROUP BY сопоставляет строки с группой
HAVING фильтрация сгруппированных строк (фильтр для групп)
ORDER BY выбирает строки по одной. такая обработка не является реляционной

фильтры TOP и OFFSET-FETCH обрабатываются на своем собственном этапе с номером 7


